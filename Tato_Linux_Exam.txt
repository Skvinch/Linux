1.
"cd" change directory. cd /home/baronvonalex/Music
"ls" მიმდინარე დირექტორიის შიგთავსი.
"pwd" Print Working Directory
"cat" ტექსტური ფაილის წასაკითხად. cat file2
"less" ისრებით შეგვიძლია ზევით/ქვევით, გვერდ-გვერდ/ხაზ-ხაზ გადაადგილება და ფაილის შიგთავსის ამგვარად დათვალიერება. q for quit.
"more" ფაილის დასაწყისიდან ბოლოსკენ ჩამოსვლა შეგვიძლია, ასვლა აღარ.
"man" ინფორმაციის მიღება ბრძანების შესახებ. "man page" 
"--help" "-h" თუ როგორ შეიძლება სინტაქსურად გამართული ფორმით ამ ბრძანების ჩაწერა.
#####################################################################################
"absolute path" აბსოლუტური გზა ძირი დირექტორიიდან იწყება /-ით. 
"relative path" ფარდობითი გზა მიმდინარე დირექტორიით იწყება. მიმდინარე დირექტორიას
		სპეციალური სიმბოლოს მეშვეობით, "." (წერტილით) აღნიშნავენ.
 		".." (ორი წერტილი) კიმიმდინარე დირექტორიის მამა დირექტორიის აღსანიშნად გამოიყენება.
#####################################################################################
2. 		(FHS)-ს (Filesystem Hierarchy Standard)
სადღეისოდ FHS-ის მე-3 ვერსია არსებობს,რომელიც გვკარნახობს თუ რა დირექტორიები
 უნდა იყოს განთავსებული /-ში და მათში რა უნდა ინახებოდეს.
	achiko@debian:∼$ ls /
	bin etc lib media proc sbin tmp vmlinuz
	boot home lib64 mnt root srv usr
	dev initrd.img lost+found opt run sys var
#####################################################################################
3. 		მაგენერირებელი სიმბოლოები, wildcard, globbing.

"*"  	ფიფქი (star wildcard, ცნობილია აგრეთვე როგორც asterisk) აღნიშნავს
	ნებისმიერ ასო-ნიშანთა ნებისმიერ წყობას.
"?"  	კითხვის ნიშანი აღნიშნავს ერთს და მხოლოდ ერთ ნებისმიერ ასო-ნიშანს.
"[ ]" 	კვადრატული ფრჩხილები აღნიშნავს ნებისმიერ ასო-ნიშნანს იმ ასო-ნიშანთა
	რიგიდან, რომელიც მასშია ჩაწერილი.
	 [:lower:] – ლათინური ანბანის პატარა ასონიშნები
	 [:upper:] – ლათინური ანბანის დიდი ასო-ნიშნები
	 [:digit:] – ციფრები
	 [:alpha:] – ლათინური ანბანის ასო-ნიშნები
 	 [:alnum:] – ლათინური ანბანის სიმბოლოები და ციფრები.
"[! ] ან [^ ]" 	კვადრატულ ფრჩხილებში მოცემული ძახილის ნიშანი ან ქუდი აღნიშნავს იმ
		ასო-ნიშანთა რიგს, რომლებიც კვადრატულ ფრჩხილებში არ არის მოცემული.
{ } 	ფიგურული ფრჩხილები აღნიშნავს მასში ჩაწერილი, მძიმით გამოყოფილი
	გამოსახულებების ალტერნატივას. გამოსახულებაში შესაძლებელია
	რამდენიმე ასო-ნიშანიც იყოს. ასეთი ფრჩხილებში შესაძლებელია აგრეთვე
	ორი წერტილის (..) გამოყენება. ამით, ასო-ნიშნების ინტერვალის მოცემა
	შეიძლება.

* 	ყველა ფაილს.
f*.	jpg ყველა ფაილს, რომლების f-ით იწყება და მთავრდება .jpg-ით.
Documents/* 	Documents დირექტორიის ყველა ფაილს.
*abc* 	ყველა ფაილს, რომელის დასახელებაშიც abc შედის. აქ თვითონ abc
	ფაილიც იგულისხმება, რადგან * ასო-ნიშანთა ნულოვან წყობასაც გულისხმობს.
?? 	ყველა ფაილს, რომლის დასახელებაც მხოლოდ 2 ასო-ნიშანია.
[abc]* 	ყველა ფაილს, რომლებიც იწყება a-თი ან b-თი ან c-თი.
[^abc]* ყველა ფაილს, რომლებიც იწყება არა a-თი ან არა b-თი ან არა c-თი.
[a-cst]* 	ყველა ფაილს, რომლებიც იწყება ან a-დან c-ს ჩათვლით ერთ-ერთი ასონიშნით, ან s-ით და ან t-თი.
[![:digit:]]* 	ყველა ფაილს, რომლებიც არ იწყება ციფრით.
{abc,def}* 	ყველა ფაილს, რომლებიც იწყება abc-თი ან def-თი.
{1..15} 	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.
{1..15..2} 	1, 3, 5, 7, 9, 11, 13, 15.
{b..f} 	b, c, d, e, f.
{f..b} 	f, e, d, c, b.
{m..a..3} 	m, j, g, d, a.
[A-KQ-Z]*.{png,jpg,bmp}	ყველა ფაილს, რომლებიც A-დან K-მდე ან Q-დან Z-მდე ინტერვალით
			იწყება და აქვს შემდეგი გაფართოება: png, jpg და ან bmp.
*.{[jJ][pP][gG],[bB][mM][pP]} ყველა ფაილს, რომლის გაფართოებაც არის jpg ან bmp, დიდი ან
			 	პატარა ან შერეული ასოებით მოცემული.
#####################################################################################
		ფაილის შექმნა.
touch file "touch {filename}"
touch file1 file2 file3
#####################################################################################
		ფაილში უცბად ჩაწერა.
cat > file1
ctrl + d for exit.
#####################################################################################
		ფაილის და დირექტორიის წაშლა.
rm file1		-i წაშლამდე თანხმობას ელოდება მომხმარებლისგან
rm -r dir1		-r შლის დირექტორიებსაც.
			-f თანხმობის გარეშე შლის. (უგულებელყოფს -i ოფციას).
#####################################################################################
		ფაილის კოპირება, ერთი ფაილის ინფორმაციის მეორეში კოპირება.
cp file1 file2 ... directory
cp file1 ~/dir2
#####################################################################################
		დირექტორიის შექმნა.
mkdir directory "mkdir {directory name}"
touch directory/file ფაილის და დირექტორიის შექმნა ერთად.
mkdir {{0..9},{A..F}}{{0..9},{A..F}}
#####################################################################################
		ფაილის გადატანა.
mv file1 file2 ... dir1 dir2 ... directory
mv file1 ~/dir2
mv file1 file2 ამ ბრძანებით კი შესაძლებელია ფაილის სახელის გადარქმევა:
#####################################################################################
5. 		გადამისამართება.
	ლინუქსის გარემოში შეტან გამოტანა ხორციელდება სამი ნაკადით და ეს ნაკადები
შემდეგნაირადაა დანომრილი (სურ. 5.1):
 სტანდარტული შესასველელს (stdin) შეესაბამება ნომერი – 0
 სტანდარტული გამოსასვლელს (stdout) შეესაბამება ნომერი – 1
 შეცდომების გამოსასვლელს (stderr) შეესაბამება ნომერი – 2

0, 1-სა და 2-ს ფაილის დესკრიფტორები (file descriptor, მოკლედ fd) ეწოდება და,
როგორც უკვე აღვნიშნეთ, ნაგულისხმევი მნიშვნელობით, ეკრანისკენაა მიმართული.
ლინუქსში ჩვენ გვაქვს იმის საშუალება, რომ შეტან/გამოტანის მიმართულება შევცვალოთ.
#####################################################################################
">" ამას რომ ვიყენებთ, მანამდე რაც იყო ფაილში იშლება.
">>" ამას რომ ვიყენებთ, მანამდე რაც იყო ფაილში არ იშლება, უბრალოდ ემატება.
#####################################################################################
		სტანდარტული გამოსასვლელი.
სტანდარტული გამოსასვლელში არსებულ ნაკადს მიმართულება რომ შევუცვალოთ
და ეკრანის ნაცვლად სხვა ფაილისკენ გადავამისამართოთ, ვიყენებთ გადამისამართების
ოპერატორს > .
ls 1>file
ls >file სტანდარტული გამოსასვლელის გადამისამართებას.
	">"  ოპერატორის გამოყენებით file-ის შიგთავსს ბრძანების stdout გადაეწერება და
მასში დამახსოვრებული ინფორმაცია დაიკარგება. თუ გვსურს, რომ stdout არ გადაეწეროს
ფაილს, არამედ ამ უკანასკნელის შიგთავსის ბოლოს დაემატოს, მაშინ ”
">>" (ორი მეტობის
ნიშანი) ოპერატორი უნდა გამოვიყენოთ, ასე:
ls >>file
#####################################################################################
		სტანდარტული შესასვლელი
cat file1
cat >file1
cat >>file1
cat <file1
#####################################################################################
6. 		ბრძანების გადაბმა: ოპერატორები && და ||
; წერტილ-მძიმე "mkdir dir; cd dir; touch file"
&& ლოგიკური და "mkdir dir && cd dir && touch file" მუშაობს მაშინ თუ წინა ბრძანება გაიშვა.
|| ლოგიკური ან "ls file || touch file" ფაილი მაშინ შეიქმენბა თუ არ არსებობს ან პირიქით, არ შექმნის თუ არსებობს.
echo aa bb hh cc | xargs -n 1 | sort | uniq > file. " | " - pipe გადაბმა.
#####################################################################################
7.		ტექსტური რედაქტორები - nano.
nano file1.
#####################################################################################
11.		ტექსტის დამუშავება - tac, head, tail, sort, uniq.
"tac" - ფაილის შიგთავსს შებრუნებული რიგითობით, ამოტრიალებულად გვაჩვენებს.
"head" - ფაილის საწყისი ნაწილი გამოაქვს
"cat ~/dir1/file1 | head -n 3" პირველი სამი ხაზი.
"tail" - ფაილის ბოლო ნაწილი
"sort" - ით ფაილების შიგთავსს ვახარისხებთ, ნაგულისხმევი მნიშვნელობით
	 ლათინური ანბანის მიხედვით. 
	 -r ოფციით შედეგი უკუღმა
"uniq" - cat file1 | uniq
	 cat test.txt | sort | uniq
	 cat test.txt | sort | uniq -u "-u მხოლოდ უნიკალური ხაზები" 
	 cat test.txt | sort | uniq -d "-d დუბლიკატები გამოვიტანოთ"
 	 cat test.txt | sort | uniq -dc "c დავთვალოთ კიდეც ეს ხაზები"
#####################################################################################
12. 		ტექსტის შედარება - find, split, echo, xargs.
"find" - find, find ~
	find ~ -name "*.txt" ნებისმიერი ფაილი .txt
"split" - ბრძანებით შეგვიძლია დიდი ფაილი ნაწილებად დავყოთ. ნაწილებად დაყოფა შეიძლება
	  ზომით ან ხაზების რაოდენობით განვახორციელოთ.
	  split -b200 file1 Part_
"echo" -  მას გამოაქვს არგუმენტად გადაცემული ტექსტი (პირდაპირი გაგებით ექოსავით
	  იქცევა. რასაც გადასცემ, იმას ბეჭდავს ეკრანზე) და ცვლადის მნიშვნელობა.
"xargs" - ზოგადად, xargs კითხულობს მონაცემებს სტანდარტული
	  შესასვლელიდან, ამუშავებს და მათზე ასრულებს მოცემულ ბრძანებას, ნაგულისხმევი
	  მნიშვნელობით /bin/echo-ს. მოკლედ, შეგვიძლია ვთქვათ, რომ xargs თავად ქმნის
	  ბრძანებათა ხაზს. cat file1 | xargs
#####################################################################################
13.		GREP
"grep"
grep "GNU" GPL-3
grep --color "GNU" GPL-3
grep --color "a" file1
{grep --color "{search word} {file name}
#####################################################################################
14. ტექსტური რედაქტორიები - nano
nano file1 მერე რასაც გინდა შეცვლი.
#####################################################################################
15. წვდომის უფლებები chmod, chown, chgrp

chmod - u = user, g = group, o = other.
რვაობითი ორობითი ატრიბუტი
0 	000 	– – –
1 	001 	– – x
2 	010 	– w –
3 	011 	– w x
4 	100 	r – –
5 	101 	r – x
6 	110 	r w –
7 	111 	r w x
chmod 764 file
chmod 640 file
chmod u+x filename
chmod u+r,g-x filename
chmod u+rw,go=rx filename

chown
chown root file1

chgrp
chgrp joint /tmp/S
chgrp root FileName
#####################################################################################
16. პროცესები ps, top, kill
ps - პროცესების სანახავად
ps u.
ps x - ჩვენს მიერ გაშვებული ყველა პროცესი რომ ვნახოთ.
ps aux - ფონური პროცესები.
ps aux | less - გვერდებად დასათვალიერებლად less ბრძანების გამოყენება შეგიძლიათ.

პროცესის მდგომარეობები
R გაშვებული, მომუშავე პროცესი.
S დაძინებული პროცესი, რომელიც ინსტრუქციას ელოდება შესასრულებლად.
Z ზომბი პროცესი. ის აღარაფერზე რეაგირებს (პროცესი დამთავრდა, თუმცა მამა
პროცესის მიერ ვერ გაიწმინდა მეხსიერებიდან. როგორც წესი, ასეთი შემთხვევები
ცუდად დაწერილ პროგრამების გაშვებისას გხვდება).
< მაღალ პრიორიტეტულ პროცესს აღნიშნავს, ანუ უფრო მეტი CPU დრო იხარჯება მის
შესრულებაზე.
N დაბალ პრიორიტეტული.
+ წინა პლანზე არსებული პროცესი.
s სესიის ლიდერი, კონკრეტულ სესიაში წამყვანი პროცესი.

pstree - პროცესების ხე.

###
top - დინამიკურ რეჟიმში პროცესების ნახვა top ბრძანებით შეგვიძლია.
M ახარისხებს პროცესებს მეხსიერების გამოყენების მიხედვით.
P უკან ვაბრუნებთ პროცესორით დალაგების სტილს.
V გვანახებს ხისებრ სტრუქტურას.
h ან ? გვანახებს ყველა შესაძლო ბრძანებას.
###
kill
kill [-signal] PID
№ სახელი მნიშვნელობა
1 HUP ან
SIGHUP
ტრადიციულად, ეს სიგნალი პროცესს ასრულებს. ის აგრეთვე
გამოიყენება ბევრი დემონის მიერ პროცესის რეინიციალიზაციისათვის,
ანუ ამ სიგნალის მიღების შემდეგ დემონი გადაიტვირთება (გამოირთვება
და ხელახლა ჩაირთვება). შესაბამისად, ხელახლა წაიკითხავს
კონფიგურაციის ფაილს.
2 INT ან
SIGINT
შეწყვეტა. იგივეა, რაც კლავიატურიდან გადაცემული Ctrl^c
კლავიშების კომბინაციით გადაცემული სიგნალი.
15 TERM ან
SIGTERM
დამთავრება. ესაა kill ბრძანებაში ნაგულისხმევი მნიშვნელობა, თუ
სიგნალი არ არის მითითებული.
9 KILL ან
SIGKILLT
მოკვლა. ავარიული გამორთვა. გამოიყენება მაშინ, როდესაც პროცესი
დასრულების სხვა სიგნალებზე არ რეაგირებს. ამ სიგნალის გადაცემით
პროცესის სწორი გაწმენდა არ ხდება, შესაბამისად, მდგომარეობა არ
ინახება.
19 STOP ან
SIGSTOP
შეჩერება, დაპაუზება. პროგრამას არ შეუძლია ამ სიგნალის იგნორირება.
ის მას გვერდს ვერ აუვლის.
18 CONT ან
SIGCONT
STOP-ით შეჩერებულის გაგრძელება.
20 TSTP ან
SIGTSTP
შეჩერება, დაპაუზება. იგივეა რაც Ctrl^z . პროგრამას აქვს
შესაძლებლობა უგულებელყოს ეს სიგნალი.

achiko@debian:∼$ xclock &
[4] 8526
achiko@debian:∼$ kill -15 8526

kill -TERM 8526

kill -SIGTERM 8526

#####################################################################################
17. არქივი, შეკუმშვა gzip bzip2
gzip - ლინუქს სისტემებში ფაილების შესაკუმშად ხშირად გამოიყენება gzip ბრძანება
gzip foobar.txt

ვნახოთ, შეკუმშვის შედეგად (-v, --verbose ოფციის გამოყენებით) რამდენი პროცენტი
მოვიგეთ ორიგინალი ფაილის ზომაში:
achiko@debian:∼$ gzip -v foobar.txt
foobar.txt: 69.6% -- replaced with foobar.txt.gz

gzip test.txt test2.txt -  რამდენიმე ფაილი შევკუმშოთ ერთდროულად.

შევამოწმოთ შეკუმშული ფაილების ინტეგრალობა (-t ოფციით). ხომ არ მოხდა
ტექნიკური ხასიათის რამე შეფერხება შეკუმშვის პროცესში:
achiko@debian:∼$ gzip -tv foobar.txt.gz
foobar.txt.gz: OK

შევკუმშოთ ფაილი და, ამავდროულად, შევინახოთ მისი ორიგინალი ვერსია:
achiko@debian:∼$ gzip -c foobar.txt > foobar.txt.gz
achiko@debian:∼$ ls foobar.txt*
foobar.txt foobar.txt.gz

-k (--keep) ოფციით კი პირდაპირ ვაიძულებთ gzip-ს, რომ ორიგინალი ფაილი შეინახოს.
achiko@debian:∼$ gzip -k foobar.txt

###
bzip2 - 

bzip2 foobar.txt

შევკუმშოთ ფაილი და, ამავდროულად, შევინახოთ მისი ორიგინალი ვერსია:
achiko@debian:∼$ bzip2 -c foobar.txt > foobar.txt.bz2

გამოვიტანოთ შეკუმშვის შესახებ ინფორმაცია:
achiko@debian:∼$ bzip2 -v foobar.txt

შევკუმშოთ სწრაფად:
achiko@debian:∼$ bzip2 -1 foobar.txt

bzip2 ბრძანებისთვისაც სამართლიანია შეკუმშვის ხარისხის დონის მითითება
ოფციებით -1 (უსწრაფესი)-დან -9 (საუკეთესო შეკუმშვა)-მდე.
time ბრძანებით შეგვიძლია, ვნახოთ რა დრო დაიხარჯა მოცემული ბრძანების
შესასრულებლად. ასე უკეთ დავინახავთ განსხვავებას უსწრაფესსა და საუკეთესო შეკუმშვას
შორის.
achiko@debian:∼$ time bzip2 -1 foobar2.txt
achiko@debian:∼$ bunzip2 foobar2.txt.bz2
achiko@debian:∼$ time bzip2 -9 foobar2.txt

ახლა, მოდით, მოვახდინოთ რამდენიმე შეკუმშული ფაილის კონკატენაცია:
achiko@debian:∼$ bzip2 -c names.txt > file.bz2
achiko@debian:∼$ bzip2 -c versions.txt >> file.bz2

achiko@debian:∼$ echo "hello" > new file
achiko@debian:∼$ ls -l new file
-rw-r--r-- 1 achiko achiko 6 Jun 25 17:57 new_file
achiko@debian:∼$ gzip new file
achiko@debian:∼$ ls -l new file.gz
-rw-r--r-- 1 achiko achiko 35 Jun 25 17:57 new_file.gz

#####################################################################################
18. SHELL
achiko@debian:∼$ [ "abc" = "abc" ]; echo $?
0
achiko@debian:∼$ a="abc"
achiko@debian:∼$ [ -n $a ]; echo $?
0
achiko@debian:∼$ [ $a ]; echo $?
0
achiko@debian:∼$ [ -z $a ]; echo $?
1

achiko@debian:∼$ [ 8 -gt 5 ]; echo $?
0
achiko@debian:∼$ [ 8 -eq 5 ]; echo $?
1
achiko@debian:∼$ a=39;b=12
achiko@debian:∼$ [ $a -ge $b ]; echo $?
0
#############
if fi გახსენი file ნანო ბრძანებით

if Command; # თუ Command ბრძანება ჭეშმარიტია
then # მაშინ
cmd1; # შესრულდეს ბრძანება cmd1
cmd2; # შესრულდეს ბრძანება cmd2
...
fi # if-ს ვხურავთ fi-თი

###

if Command1; # თუ Command1 ბრძანება ჭეშმარიტია
then # მაშინ
cmd1; ... # შესრულდეს ბრძანება cmd1 ...
elif Command2; # თუ არა, შემოწმდეს Command2.
then # თუ ის ჭეშმარიტია, მაშინ
cmd2; ... # შესრულდეს ბრძანება cmd2 ...
.
.
.
else # წინააღმდეგ შემთხვევაში
cmdN; ... # შესრულდეს ბრძანება cmdN
fi

###

#!/bin/bash
x=8
y=17
if [ $x -eq $y ]
then
echo "$x ტოლია $y-ის"
else
echo "$x არ არის $y-ის ტოლი!"
fi
achiko@debian:∼$ ./script XYZ.sh
8 არ არის 17-ის ტოლი!


მიმატება გამოკლება: 
((a=5))
((b=6))
((c=a+b))
echo $c























